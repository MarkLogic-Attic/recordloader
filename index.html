<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--
/*
 * Copyright (c)2005-2011 Mark Logic Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The use of the Apache License does not indicate that this project is
 * affiliated with the Apache Software Foundation.
 */
-->
<head>
<title>RecordLoader README</title>
<style>
td
{
  vertical-align: top;
}
</style>
</head>
<body>
<h1>RecordLoader</h1>

<p>
To get started with RecordLoader, try the <a href="tutorial.html">tutorial</a>.
For the source code, see the
<a href="http://github.com/marklogic/recordloader">project page on github</a>.
</p>

<h2>Running RecordLoader</h2>
<p>The entry point is the main method in the
 com.marklogic.ps.RecordLoader class.
The command-line arguments may be any mix of zero or more property files
and zero or more input files.
</p>

<p>Any property file names must end in <code>.properties</code>.
Other file names on the command line
will be treated as input files, not property files.
Any specified system properties will override file-based properties,
and properties found in later files may override properties
specified in earlier files on the command line.
It's also possibly to specify properties as VM arguments (-DNAME=value).
See
<code><a href="http://github.com/marklogic/recordloader/raw/master/src/recordloader.sh">src/recordloader.sh</a></code>
for a sample shell script.
See <code><a href="http://github.com/marklogic/recordloader/tree/master/src/config/">src/config/</a></code>
for sample property files.
</p>

<p>
Input files will be used as input for the loader.
The input file names must <b>not</b> end in <code>.properties</code>.
These may be binary, text, or XML (see <code>INPUT_FORMAT</code>, below).
XML files may be single documents or superfiles containing many documents
(see <code>RECORD_NAME</code> below).
</p>

<h2>Required JVM: Sun 1.5 or later</h2>

<h2>Required libraries:</h2>
<ul>
  <li>MarkLogic <a href="http://developer.marklogic.com/">XCC</a></li>
  <li><a href="recordloader.jar">recordloader.jar</a></li>
  <li><a href="http://www.extreme.indiana.edu/xgws/xsoap/xpp/">XPP3</a>
  XML Pull-Parser
  (here's a link to the
  <a href="http://www.extreme.indiana.edu/dist/java-repository/xpp3/jars/">jar
  files</a> - be sure to use xpp3-1.1.4c.jar or later)
  </li>
  <li><a href="https://github.com/junit-team/junit/wiki/Download-and-Install">junit.jar</a></li>
  <li><a href="http://svnkit.com/download.php">svnkit.jar</a></li>
</ul>

<h2>Required inputs:</h2>
<p>
None. If <code>ID_NAME</code> is missing,
then the default value <code>#FILENAME</code> will be used.
</p>

<h2>Available properties:</h2>
<table border="1">
<tr><th>Property</th><th>default value</th><th>notes</th></tr>

<tr><td>CONFIGURATION_CLASSNAME</td>
<td>com.marklogic.recordloader.xcc.XccConfiguration</td>
<td>This class will be used to provide configuration information.
This class must be an extension of the
com.marklogic.recordloader.Configuration class.</td>
</tr>

<tr><td>CONTENT_FACTORY_CLASSNAME</td>
<td>com.marklogic.recordloader.xcc.XccContentFactory</td>
<td>
<p>This class will be used to create new content objects,
which implement com.marklogic.recordloader.ContentInterface.
One alternative implementation is provided, as
<code>com.marklogic.recordloader.xcc.XccModuleContentFactory</code>,
which creates objects in the class
<code>com.marklogic.recordloader.xcc.XccModuleContent</code>.
</p>

<p>
When XccModuleContentFactory is used, new documents must fit in memory,
and will be posted to the XQuery main module designated by the
<code>CONTENT_MODULE_URI</code> property.
If the <code>SKIP_EXISTING</code> or <code>ERROR_EXISTING</code>
features are desired, the module must implement each itself (see below).
</p>

<p>When RecordLoader invokes this module, it will set external variables:
</p>

<ul>
<li><code>$URI</code></li>
<li><code>$XML-STRING</code></li>
<li><code>$NAMESPACE</code>&nbsp;
  (using <code>DEFAULT_NAMESPACE</code>)
</li>
<li><code>$LANGUAGE</code>&nbsp;
  (using <code>LANGUAGE</code>)
</li>
<li><code>$ROLES-EXECUTE</code>&nbsp;
  (comma-separated values, using <code>ROLES_EXECUTE</code>)
</li>
<li><code>$ROLES-INSERT</code>&nbsp;
  (comma-separated values, using <code>ROLES_INSERT</code>)
</li>
<li><code>$ROLES-READ</code>&nbsp;
  (comma-separated values, using <code>ROLES_READ</code>)
</li>
<li><code>$ROLES-UPDATE</code>&nbsp;
  (comma-separated values, using <code>ROLES_UPDATE</code>)
</li>
<li><code>$COLLECTIONS</code>&nbsp;
  (comma-separated values, using any base collections
  plus <code>OUTPUT_COLLECTIONS</code>)
</li>
<li><code>$SKIP-EXISTING</code>&nbsp;
  (using <code>SKIP_EXISTING</code>)
</li>
<li><code>$ERROR-EXISTING</code>&nbsp;
  (using <code>ERROR_EXISTING</code>)
</li>
<li><code>$FORESTS</code>&nbsp;
  (comma-separated forest ids, via <code>OUTPUT_FORESTS</code>)
</li>
</ul>

<p>
  The following XQuery implements an example ContentModule,
  which implements a simple transform to lower-case all element names.
  Note that the module implements its own versions of the
  <code>SKIP_EXISTING</code> and <code>ERROR_EXISTING</code> checks.
</p>

<pre>
xquery version "1.0-ml";

declare variable $URI as xs:string external;
declare variable $XML-STRING as xs:string external;
declare variable $NAMESPACE as xs:string external;
declare variable $LANGUAGE as xs:string external;
declare variable $ROLES-EXECUTE as xs:string external;
declare variable $ROLES-INSERT as xs:string external;
declare variable $ROLES-READ as xs:string external;
declare variable $ROLES-UPDATE as xs:string external;
declare variable $COLLECTIONS as xs:string external;
declare variable $SKIP-EXISTING as xs:boolean external;
declare variable $ERROR-EXISTING as xs:boolean external;
declare variable $FORESTS as xs:string external;

declare function local:do($list as node()*)
 as node()*
{
  for $n in $list return typeswitch($n)
  (: lower-case element localnames :)
  case element() return element {
    QName(namespace-uri($n), lower-case(local-name($n)))
  } {
    $n/@*, local:do($n/node())
  }
  case document-node() return document { local:do($n/node()) }
  default return $n
};

if ($SKIP-EXISTING and doc($URI)) then ()
else if ($ERROR-EXISTING and doc($URI)) then error((), 'DUPLICATE-URI', $URI)
else xdmp:document-insert(
  $URI,
  local:do(xdmp:unquote(
    $XML-STRING,
    $NAMESPACE,
    if ($LANGUAGE) then concat('default-language=', $LANGUAGE) else ()
  )),
  (
    for $r in tokenize($ROLES-EXECUTE, ',')[. ne '']
    return xdmp:permission('execute', $r),
    for $r in tokenize($ROLES-INSERT, ',')[. ne '']
    return xdmp:permission('insert', $r),
    for $r in tokenize($ROLES-READ, ',')[. ne '']
    return xdmp:permission('read', $r),
    for $r in tokenize($ROLES-UPDATE, ',')[. ne '']
    return xdmp:permission('update', $r)
  ),
  tokenize($COLLECTIONS, ',')[. ne ''],
  0,
  for $id in tokenize($FORESTS, ',')[. ne '']
  return xs:unsignedLong($id)
)
</pre>

<p>Another included factory is
  <code>com.marklogic.recordloader.http.HttpContentFactory</code>.
  This is similar to the XCC version above,
  except that the implementation must use
  <code>xdmp:get-request-field()</code> rather than
  declaring <code>external</code> to populate the module variables.
  Note that some variables take <code>xs:string*</code>
  rather than <code>xs:string</code>: these are
  <code>COLLECTIONS</code>,
  <code>FORESTS</code>,
  <code>ROLES-EXECUTE</code>.
  <code>ROLES-INSERT</code>.
  <code>ROLES-READ</code>.
  and <code>ROLES-UPDATE</code>.
  The <code>xs:boolean</code> variables are <code>xs:string</code> instead.
  Also, <code>FORESTS</code> will be passed in as forest names,
  so the module must be prepared to translate these into forest ids.
</p>

<pre>
declare variable $URI as xs:string := xdmp:get-request-field(
  'URI');
declare variable $XML-STRING as xs:string := xdmp:get-request-field(
  'XML-STRING');
declare variable $NAMESPACE as xs:string := xdmp:get-request-field(
  'NAMESPACE');
declare variable $LANGUAGE as xs:string := xdmp:get-request-field(
  'LANGUAGE');
declare variable $ROLES-EXECUTE as xs:string* := xdmp:get-request-field(
  'ROLES-EXECUTE);
declare variable $ROLES-INSERT as xs:string* := xdmp:get-request-field(
  'ROLES-INSERT);
declare variable $ROLES-READ as xs:string* := xdmp:get-request-field(
  'ROLES-READ');
declare variable $ROLES-UPDATE as xs:string* := xdmp:get-request-field(
  'ROLES-UPDATE);
declare variable $COLLECTIONS as xs:string* := xdmp:get-request-field(
  'COLLECTIONS');
declare variable $SKIP-EXISTING as xs:boolean := xs:boolean(
  xdmp:get-request-field('SKIP-EXISTING'));
declare variable $ERROR-EXISTING as xs:boolean := xs:boolean(
  xdmp:get-request-field('ERROR-EXISTING'));
declare variable $FORESTS as xs:string* := xdmp:get-request-field(
  'FORESTS');

if ($SKIP-EXISTING and doc($URI)) then ()
else if ($ERROR-EXISTING and doc($URI)) then error((), 'DUPLICATE-URI', $URI)
else xdmp:document-insert(
  $URI,
  xdmp:unquote(
    $XML-STRING,
    $NAMESPACE,
    if ($LANGUAGE) then concat('default-language=', $LANGUAGE) else ()
  ),
  (
    for $r in tokenize($ROLES-EXECUTE, ',')[. ne '']
    return xdmp:permission('execute', $r),
    for $r in tokenize($ROLES-INSERT, ',')[. ne '']
    return xdmp:permission('insert', $r),
    for $r in tokenize($ROLES-READ, ',')[. ne '']
    return xdmp:permission('read', $r),
    for $r in tokenize($ROLES-UPDATE, ',')[. ne '']
    return xdmp:permission('update', $r)
  ),
  $COLLECTIONS,
  0,
  for $fn in $FORESTS return xdmp:forest($fn)
)
</pre>

</td>
</tr>

<tr><td>CONNECTION_STRING</td><td>xcc://admin:admin@localhost:9000/</td>
<td>
  XCC URI, including username, password, host, and port,
  to use for all queries and inserts.
  If desired, a database name may also be supplied.
  Multiple connection strings may be separated with whitespace or commas.
  To use SSL with MarkLogic Server 4.1, start the connection string
  with the <code>xccs://</code> scheme
  rather than the default <code>xcc://</code> scheme.
</td>
</tr>

<tr><td>DEFAULT_NAMESPACE</td><td>null</td>
<td>If present, all XML will default to the supplied namespace uri.</td>
</tr>

<tr><td>DELETE_INPUT_FILES</td>
<td>false</td>
<td>If true, each input file will be deleted after being loaded.
  This setting does not affect zip archives.
  This setting does not delete directories.
  If <code>FATAL_ERRORS</code> is false,
  then the input document may be deleted even though errors have occured.
</td>
</tr>

<tr><td>DOCUMENT_FORMAT</td><td>xml</td>
<td>Document format for all new documents.
  Valid settings are
  <code>xml</code>, <code>text</code>, and <code>binary</code>
</td>
</tr>

<tr><td>ENCRYPTED_PASSWORD</td><td>false</td>
<td>
<p>
Not everyone wants to include their password in the properties file. A
"little" bit of security was added by adding the ENCRYPTED_PASSWORD
Flag.  When this flag is enabled the recordloader process will look
for the "ciphertext" and "keyfile" files that contain the encrypted
password to be used.  To create the two encrypted password files,
execute:
</p>
<pre>
java -cp recordloader.jar com.marklogic.ps.PasswordEncrypter PASSWORD
</pre>
</p>
Change PASSWORD to be the password that becomes encrypted
Now the properties file does not contain a password, and the encrypted
password files can be kept seperate, securely and non-human readable.
</p>
</td>
</tr>

<tr><td>ENCRYPTED_PASSWORD</td><td>false</td>
<td>
<p>
Not everyone wants to include their password in the properties file. A
"little" bit of security was added by adding the ENCRYPTED_PASSWORD
Flag.  When this flag is enabled the recordloader process will look
for the "ciphertext" and "keyfile" files that contain the encrypted
password to be used.  To create the two encrypted password files,
execute:
</p>
<pre>
java -cp recordloader.jar com.marklogic.ps.PasswordEncrypter PASSWORD
</pre>
</p>
Change PASSWORD to be the password that becomes encrypted
Now the properties file does not contain a password, and the encrypted
password files can be kept seperate, securely and non-human readable.
</p>
</td>
</tr>

<tr><td>ERROR_EXISTING</td><td>false</td>
<td>
  If true, RecordLoader will throw an error
  if it finds itself trying to overwrite an existing document uri.
  This error may or may not be fatal,
  depending on the value of <code>FATAL_ERRORS</code>.

<p>
  Note that this option requires the server to perform a separate check
  for each document uri. This can reduce performance.
</p>

<p>
  Note that if using
  <code>CONTENT_FACTORY_CLASSNAME=com.marklogic.recordloader.xcc.XccModuleContentFactory</code>,
  this option requires the module to implement its mechanism (see above).
</p>

</td>
</tr>

<tr><td>FATAL_ERRORS</td><td>true</td>
<td>If true, RecordLoader will exit with an error
  upon encountering any non-retryable error.
  If set to false, RecordLoader will close the current record
  and continue on to the next.
</td>
</tr>

<tr><td>ID_NAME</td><td><code>#FILENAME</code></td>
<td>Within each input document or RECORD_NAME element,
the first element called ID_NAME will be used to compose the new document uri.
If ID_NAME starts with '@', an attribute with this local-name
will be used to compose the new document uri.
<p>
Note that namespace is ignored: only the local-name is used.
The named node must have a simple text value:
it may not be empty, and it must not contain any non-text children.
</p>
<p>
The special value <code>ID_NAME=#AUTO</code> will cause RecordLoader
to automatically generate ids, in sequence, for each input record.
Since RecordLoader automatically includes the base filename
in each output URI, this is safe.
</p>
<p>
Note that when the input is standard input,
the default value is <code>#AUTO</code> - not <code>#FILENAME</code>.
</p>
<p>
The special value <code>ID_NAME=#FILENAME</code> will cause RecordLoader
to automatically load each input file into
a single document per input file, using the file's basename
to compose the new document uri. This is the default behavior.
</p>
<p>
Examples: ID_NAME=MedlineID, ID_NAME=@id</td>
</p>
</tr>

<tr><td>IGNORE_FILE_BASENAME</td><td>false</td>
<td>
  If true, RecordLoader will omit the file or zip archive basename
  when composing new document uris.
</td>
</tr>

<tr><td>IGNORE_UNKNOWN</td><td>false</td>
<td>If set, RecordLoader will ignore siblings of RECORD_NAME
that are not RECORD_NAME elements.
Otherwise, this condition causes a fatal error.</td>
</tr>

<tr><td>INPUT_MALFORMED_ACTION</td><td>REPORT</td>
<td>Constant values from java.nio.charset.CodingErrorAction,
used to determine what happens if there are
invalid character sequences in the input XML.
<ul>
<li>REPORT: throws a MalformedInputException</li>
<li>REPLACE: replaces invalid sequence with a '?' or similar.</li>
<li>IGNORE: skips over the invalid sequence.</li>
</ul>
</td>
</tr>

<tr><td>INPUT_ENCODING</td><td>UTF-8</td>
<td>The Java Charset encoding (codepage) to use for all input XML.
If unset, RecordLoader will use null,
which will default to the default Locale's character encoding.
<br/>
Note that MarkLogic Server must receive all XML as UTF-8,
so the output encoding is always UTF-8.
<br/>
<b>Example</b>: if the input XML is encoded as <code>windows-1252</code>,
use <code>INPUT_ENCODING=Cp1252</code> to ensure correct conversion.
</td>
</tr>

<tr>
  <td>INPUT_ESCAPE_IDS</td><td>true</td>
  <td>
    If true, all input ids will be URI-escaped.
    Note that the default is true if <code>ID_NAME=#FILENAME</code>,
    which is the default. In other modes, the default is false.
  </td>
</tr>

<tr><td>INPUT_FILE_SIZE_LIMIT</td><td>0</td>
<td>
  If greater than zero, RecordLoader will skip any input files
  larger that <code>INPUT_FILE_SIZE_LIMIT</code> Bytes.
  This does not apply to zip archives, nor to the size of their entries.
</td>
</tr>

<tr>
<td>INPUT_HANDLER_CLASSNAME</td>
<td>com.marklogic.recordloader.DefaultInputHandler</td>
<td>
The specified class will be used to marshall loader inputs.
The default class handles <code>INPUT_PATH</code>
as well as command-line arguments.
This property is meant for plug-in classes, which must implement
com.marklogic.recordloader.InputHandlerInterface,
and may extend the com.marklogic.recordloader.AbstractInputHandler
class.
<br/>
Built-in alternatives:
<ul>
<li>com.marklogic.recordloader.svn.SvnInputHandler
  treats <code>INPUT_PATH</code> as a subversion repository url
  (EXPERIMENTAL).
</li>
</ul>
</td>
</tr>

<tr><td>INPUT_PATH</td><td>null</td>
<td>The filesystem path in which to look for XML files or zip archives.
If unset, RecordLoader will read XML directly from standard input.</td>
</tr>

<tr><td>INPUT_PATTERN</td><td>^.+\\.[Xx][Mm][Ll]$</td>
<td>Matching pattern (regex) for files found in INPUT_PATH.
The default value matches all filenames ending with <code>.xml</code></td>
</tr>

<tr><td>INPUT_STREAMING</td><td>false</td>
<td>If true, the input content will be streamed into the database.
  By default, content will be buffered one document at a time, per thread.
  The streaming option requires less memory, but is more fragile:
  if interrupted, a document insert cannot be retried.
</td>
</tr>

<tr><td>INPUT_STRIP_PREFIX</td><td>null</td>
<td>If not null, characters matching this pattern (regex)
  will be removed from all input URIs.
  For example, Windows users may wish to set
  <code>INPUT_STRIP_PREFIX=^[A-Z]:</code>
  so that document URIs in the database
  do not include drive-letter prefixes.
</td>
</tr>

<tr><td>INPUT_NORMALIZE_PATHS</td><td>false</td>
<td>If true, backslashes in input paths
  will be coalesced and replaced with slashes
  in all output document URIs.
  This is useful for Windows users,
  especially in combination with <code>INPUT_STRIP_PREFIX</code>.
  With both properties set as suggested,
  <code>C:\foo\bar\baz.xml</code> on the filesystem becomes
  <code>/foo/bar/baz.xml</code> in the database.
</td>
</tr>

<tr>
  <td>LANGUAGE</td><td>null</td>
  <td>
    If set, the value will be passed
    to XCC <code>ContentCreateOptions.setLanguage()</code>,
    or to the <code>CONTENT_MODULE</code>
    external variable <code>$LANGUAGE</code>.
    Accepted values are documented
    in <a href="http://www.w3.org/TR/2006/REC-xml-20060816/#sec-lang-tag">XML 1.0</a>
    and <a href="http://www.ietf.org/rfc/rfc3066.txt">RFC 3066</a>.
    <p>If null, the default database language will be used.</p>
  </td>
</tr>

<tr>
  <td>LOG_LEVEL</td><td>INFO</td>
  <td>java.util.logger.Level at which to log.</td>
</tr>

<tr>
  <td>LOG_HANDLER</td><td>CONSOLE,FILE</td>
  <td>java.util.logger log handlers with which to log.</td>
</tr>

<tr>
  <td>LOOP_FOREVER</td>
  <td>false</td>
  <td>
    If set, RecordLoader will loop forever on the arguments and properties.
    This is most useful when combined with <code>DELETE_INPUT_FILES</code>.
  </td>
</tr>

<tr><td>OUTPUT_COLLECTIONS</td><td>null</td>
<td>One or more collections to apply to every new document.
Use whitespace to separate multiple collection uris.
Note that the actual document collections will also include
so-called "base collections". One of these is a batch marker,
<code>com.marklogic.ps.RecordLoader.{ system milliseconds }</code>.
This base collection can be useful for tracking how and when
documents were ingested.
Another base collection is derived from
the input filename (see <code>USE_FILENAME_COLLECTION</code>).
Another base collection is derived from
the current wall-clock time (see <code>USE_TIMESTAMP_COLLECTION</code>).
</td>
</tr>

<tr><td>OUTPUT_FORESTS</td><td>null</td>
<td>If set, all documents will be explicitly placed into the named forests.
Use whitespace or the characters <code>,:;</code> to separate values.</td>
</tr>

<tr><td>OUTPUT_QUALITY</td><td>0</td>
<td>When using XccContentFactory for inserts,
this value will be used to set document quality.
</tr>

<tr><td>ROLES_EXECUTE</td><td>null</td>
<td>One or more existing role name, separated by whitespace.
If set, every document inserted by RecordLoader
will have execute permission for these roles.
If any of the supplied role-names do not exist,
the first document insert will throw a fatal error.</td>
</tr>

<tr><td>ROLES_INSERT</td><td>null</td>
<td>One or more existing role name, separated by whitespace.
If set, every document inserted by RecordLoader
will have insert permission for these roles.
If any of the supplied role-names do not exist,
the first document insert will throw a fatal error.</td>
</tr>

<tr><td>ROLES_READ</td><td>null</td>
<td>One or more existing role name, separated by whitespace.
If set, every document inserted by RecordLoader
will have read permission for these roles.
If any of the supplied role-names do not exist,
the first document insert will throw a fatal error.
</td>
</tr>

<tr><td>ROLES_UPDATE</td><td>null</td>
<td>One or more existing role name, separated by whitespace.
If set, every document inserted by RecordLoader
will have update permission for these roles.
If any of the supplied role-names do not exist,
the first document insert will throw a fatal error.</td>
</tr>

<tr><td>RECORD_NAME</td><td>null</td>
<td>
<p>Element name in which each document is found. These may not nest.
If no RECORD_NAME is set, the first child element
of the first root element
will be used for the entire RecordLoader run.
</p>
<p>If <code>ID_NAME</code> is set to an element or attribute name,
or set to <code>#AUTO</code>
  (including when RecordLoader reads from standard input),
then the special value <code>RECORD_NAME=#DOCUMENT</code>
will cause RecordLoader to treat every document root element as a record.
This mode is slower than <code>ID_NAME=#FILENAME</code>,
but useful when the filenames are not appropriate as document URIs.
</p>
</td>
</tr>

<tr><td>RECORD_NAMESPACE</td><td>null</td>
<td>Element namespace in which each document is found.
If unset, but RECORD_NAME is set, then the empty namespace is assumed.
If unset, and RECORD_NAME is also unset,
then then the namespace of the first child element
of the first root element
will be used for the entire RecordLoader run.</td>
</tr>

<tr><td>SKIP_EXISTING</td><td>false</td>
<td>
<p>
  If true, existing document uris will be skipped.
  This allows RecordLoader to resume after being interrupted.
  This option may be combined with <code>START_ID</code>,
  in case the known value for <code>START_ID</code> already exists.

</p>
<p>
  Note that one read I/O is required per skip,
  so SKIP_EXISTING is slower than using START_ID (below).
</p>
<p>

  Note that if using
  <code>CONTENT_FACTORY_CLASSNAME=com.marklogic.recordloader.xcc.XccModuleContentFactory</code>,
  this option requires the module to implement its mechanism (see above).
</p>
</td>
</tr>

<tr><td>SKIP_EXISTING_UNTIL_FIRST_MISS</td><td>false</td>
<td>If true, existing documents will be skipped until the first miss
is found. This can be somewhat faster than <code>SKIP_EXISTING</code> alone,
but may result in updates to some existing documents.
</td>
</tr>

<tr><td>START_ID</td><td>null</td>
<td>
  When set, records are skipped
  until one with an <code>ID_NAME</code> value
  equal to <code>START_ID</code> is found.
  This can be used to resume ingestion after interruptions or fatal errors.
</td>
</tr>

<tr><td>START_ID_MULTITHREADED</td><td>false</td>
<td>
  Normally, <code>START_ID</code> causes RecordLoader to temporarily reduce
  <code>THREADS</code> to 1 until the starting value is found.
  When this property is true, RecordLoader allows multiple threads to run
  even before the start value has been found.
  Before the start value has been found, all threads will skip
  their input records. Once the start value has been found by one thread,
  all threads will begin processing records input normally.
  <br/>
  Enabling this property can sometimes be useful,
  but may result in unpredictable or non-deterministic behavior.
</td>
</tr>

<tr><td>THREADS</td><td>1</td>
<td>
<p>
Number of RecordLoader threads.
</p>
<p>
Note that when using standard input, this value is ignored.
</p>
<p>
Note that RecordLoader uses at most 1 thread per input file or zip entry.
</p>
</td>
</tr>

<tr><td>THROTTLE_BYTES_PER_SECOND</td><td>0</td>
<td>If non-zero, all threads will be throttled
  to the given number of bytes inserted per second.</td>
</tr>

<tr><td>THROTTLE_EVENTS_PER_SECOND</td><td>0</td>
<td>If non-zero, all threads will be throttled
  to the given number of inserts per second.</td>
</tr>

<!--
<tr><td>TOOMANYSTANDS_RETRY_MS</td><td>0</td>
<td>If non-zero, and using FileLoader,
  and the exception XDMP-TOOMANYSTANDS is raised,
  the worker thread will sleep for the given number milliseconds
  before retrying.</td>
</tr>
-->

<tr><td>URI_PREFIX</td><td>null</td>
<td>Prefix used before the ID_NAME value, to compose all document uris.
If the prefix does not end in '/', RecordLoader will add a '/' to it.
</td>
</tr>

<tr><td>URI_SUFFIX</td><td>null</td>
<td>Suffix used after the ID_NAME value, to compose all document uris.</td>
</tr>

<tr><td>USE_FILENAME_COLLECTION</td><td>true</td>
<td>If <code>ID_NAME</code> is not <code>#FILENAME</code>,
  and this property is true,
  RecordLoader will add an extra collection to each record,
  built from the filename of the current input file.
  This can be useful when splitting superfiles.
</td>
</tr>

<tr><td>USE_TIMESTAMP_COLLECTION</td><td>true</td>
<td>If this property is true,
  RecordLoader will add an extra collection to each record,
  built from the timestamp at which RecordLoader started running.
  This can be useful when tracking down problems with content
  loaded at different times.
</td>
</tr>

<tr><td>XML_REPAIR_LEVEL</td><td>NONE</td>
<td>To what degree should XPP3 and MarkLogic Server
compensate for invalid XML?
<ul>
<li>NONE: throw an exception (see also: <code>FATAL_ERRORS</code>).</li>
<li>FULL: do everything reasonable to ingest the document.</li>
</ul>
</td>
</tr>

</table>

<h2>Troubleshooting</h2>
<h3>
  <code>XmlPullParserException: could not resolve entity named 'foo'</code>.
</h3>
<p>
The XPP implementation used by RecordLoader, xpp3,
does not handle unknown references,
and does not process DTD-style document declarations.
So if your XML includes non-XML character entities,
RecordLoader is not for you.
Future enhancements could include a plug-in system,
allowing the user to substitute an XPP implementation
that supports document declarations.
</p>

<h3>
<code>java.util.concurrent.RejectedExecutionException</code>.
</h3>
<p>
If you are using RecordLoader with thousands of files or zipfile entries,
you may need to increase the JVM heap space. Try <code>-Xmx256m</code>
as one of your command-line JVM arguments.
</p>

<h3>
With Solaris, my UTF-8 accents and diacritics are mangled.
</h3>
<p>
You should see UTF-8 in the output from <code>locale -a</code>:
</p>
<p><code>
$ locale -a | grep -i utf
en_CA.UTF-8
en_US.UTF-8
es.UTF-8
es_MX.UTF-8
fr.UTF-8
fr_CA.UTF-8
</code>
</p>
<p>
  If no UTF-8 locales are available,
  make sure to install the correct Solaris packages:
</p>

<ul>
  <li><code>SUNWeuluf</code></li>
  <li><code>SUNWeu8os</code></li>
  <li><code>SUNWicu</code></li>
  <li><code>SUNWicud</code></li>
</ul>

</body>
</html>
